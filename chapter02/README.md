# 2.1 基本内置类型
* 算术类型 和 空类型

## 2.1.1 算术类型

* 练习 2.1 类型 int, long, long long 和 short 的区别是什么 ？ 无符号类型和带符号类型的区别是什么 ？ float 和 double 的区别是什么 ？
  
* 练习 2.2 计算按揭贷款时，对于利率，本金和付款分别应选择何种数据类型 ？ 说明你的理由。
  
## 2.1.2 类型转换

* 练习 2.3 读程序写结果
    ```
    unsigned u = 10, u2 = 42;
    std::cout << u2 - u << std::endl;
    std::cout << u - u2 << std::endl;

    int i = 10, i2 = 42;
    std::cout << i2 - i << std::endl;
    std::cout << i - i2 << std::endl;
    std::cout << i - u << std::endl;
    std::cout << u - i << std::endl;
    ```
    结果
    ```
    32
    4294967264
    32
    -32
    0
    0
    ```    
* 练习 2.4 编写程序检查你的估计是否正确，如果不正确，请仔细研读本节直到弄明白问题所在。

## 2.13 字面值常量

* 练习 2.5 指出下述字面值的数据类型并说明每一组内有几种字面值的区别
    ```
    a. 'a', L'a', "a", L"a"
    b. 10, 10u, 10L, 10uL, 012, 0xC
    c. 3.14, 3.14f, 3.14L
    d. 10, 10u, 10., 10e-2
    ```

* 练习 2.6 下面俩组定义是否有区别，如果有，请叙述之
    ```
    int month = 9, day = 7;  // ✅
    int month = 09, day = 07; // ❌
    ```

* 练习 2.7 下面字面值表示何种含义 ？ 它们各自的数据类型是什么 ？
    ```
    a. "Who goes with F\145rgus?\012"
    b. 3.14e1L
    c. 1024f
    d. 3.14L
    ```

* 练习 2.8 请利用转义序列编写一段程序，要求先输出 2M ，然后转到新一行。修改程序使其输出 2，然后输出制表符，再输出 M， 最后转到新一行。
    ```
    #include <iostream>

    int main()
    {
        std::cout << "2M\n";
        std::cout << "2" << "\n" << "M\n"; 
        return 0;
    }
    ```

# 2.2 变量

## 2.2.1 变量定义

* 练习 2.9 解释下列定义的含义。对于非法的定义，请说明错在何处并将其改正。
    ```
    a. std::cin >> int input_value;
    b. int i = { 3.14 };
    c. double salary = wage = 9999.99;
    d. int i = 3.14;
    ```
    正确答案
    ```
    a. int input_value; std::cin >> input_value;
    b. double i = 3.14;
    c. duoble salary, wage; salary = wage = 9999.99;
    d. double i = 3.14;
    ```

* 练习 2.10 下列变量的初值分别是什么 ？ 
    ```
    std::string global_str; // ""
    int global_int; // 0
    int main()
    {
        int local_int;  // unknow
        std::string local str;  // unknow
    }
    ```
## 2.2.2 变量声明和定义的关系
* 变量声明 
* 变量定义
    ```
    extern int i; // 声明 i 而非定义 i
    int j; // 声明并定义 j
    extern double pi = 3.1416; // 定义
    ```

* 指出下面的语句是声明还是定义
    ```
    a.extern int ix = 1024;  // 声明ix并且定义ix
    b.int iy;  // 定义ix
    c.extern int iz;  // 声明iz
    ```
## 2.2.3 标识符

* 练习 2.12 请指出下面的名字中哪些是非法的 ？
    ```
    a.int double = 3.14; // ❌
    b.int _; // ❌
    c.int catch-22; // ❌
    d.int 1_or_2 = 1; // ❌
    e.double Double = 3.14; // ❌
    ```

## 2.2.4 名字的作用域
* 通过下面这段程序理解名字的作用域
    ```
    #include <iostream>

    // 该程序仅用于说明：函数内部不宜定义与全局变量同名的新变量
    int reused = 42; // reused拥有全局作用域
    int main()
    {
        int unique = 0; // unique拥有块作用域
        // 输出 #1：使用全局变量reused；输出 42 0
        std::cout << reused << " " << unique << std::endl;
        int reused = 0; // 新建局部变量reused，覆盖了全局变量reused
        // 输出 #2：使用局部变量reused；输出 0 0
        std::cout << reused << " " << unique << std::endl;
        // 输出 #3： 显式地访问全局变量reused； 输出 42 0
        std::cout << ::reused << " " << unique << std::endl;
        return 0;
    }
    ```

* 练习 2.13 下面的程序中 j 的值是多少？
    ```
    #include <iostream>

    int main()
    { 
        int i = 100, sum = 0;
        for (int i = 0; i != 10; ++ i ) 
            sum += i;
        std::cout << i << " " << sum << std::endl;
        return 0;
    }
    ```

* 练习 2.14 下面的程序合法吗 ？如果合法，它将输出什么 ？
    ```
    #include <iostream>

    int main()
    { 
        int i = 100, sum = 0;
        for (int i = 0; i != 10; ++ i ) 
            sum += i;
        std::cout << i << " " << sum << std::endl;
        return 0;
    }
    ```

# 2.3 复合类型
* 复合类型（compound type）是指基于其他类型定义的类型。C++ 有几种复合类型，这里介绍俩种：引用和指针。

## 2.3.1 引用
* 引用即别名 引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字

* 练习 2.15 下面的哪个定义是不合法的？为什么？
    ```
    a. int ival = 1.01; ✅
    b. int &rval1 = 1.01; // ❌ 引用类型的初始值必须是一个对象
    c. int &rval2 = ival; ✅
    d. int &rval3;  // ❌ 为初始化
    ```
* 练习 2.16 考察下面的所有赋值然后回答：哪些赋值是不合法的？为什么？哪些赋值是合法的？它们执行了什么样的操作？
    ```
    int i = 0, &r1 = i;
    double d = 0, &r2 = d;
    a. r2 = 3.14159; // ✅
    b. r2 = r1; // ✅
    c. i = r2; // ✅
    d. r1 = d; // ✅
    ```

* 练习 2.17 执行下面的代码段将输出什么结果
    ```
    int i, &ri = i;
    i = 5; ri = 10;
    std::cout << i << " " << ri << std::endl;
    ```
    输出结果
    ```
    10 10
    ```

## 2.3.2 指针
* 指针(pointer)是“指向(point to)” 另外一种类型的复合类型。与引用类似，指针也实现了对其他对象的间接访问。然而指针与引用相比 又有很多不同点。其一，指针本身就是一个对象，允许对指针赋值和找贝，而且在指针的生命周期内它可以先后指向几个不同的对象。其二，指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。

* 获取对象的地址
指针存放某个对象的地址，要想获取改地址，需要使用去地址符（操作符&）
    ```
    int ival = 42;
    int *p = &ival; // p存放变量ival的地址，或者说p是指向变量ival的指针
    ```
* 所有指针的类型都要和它所指向的对象严格匹配
    ```
    double dval;  
    double *pd = &dval; // 正确：初始值是double型对象的地址
    double *pd2 = pd;  // 正确：初始值是指向double对象的指针
    int *pi = pd;   // 错误：指针pi的类型和pd的类型不匹配
    pi = &dval;   // 错误：试图把double型对象的地址赋给int型指针
    ```
* 利用指针访问对象
如果指针指向了一个对象，则允许使用解引用符（操作符*）来访问该对象
    ```
    int ival = 42;
    int *p = &ival;  // p存放着变量ival的地址，或者说p是指向变量ival的指针
    cout << *p;  // 由符号*得到指针p所指的对象，输出42
    *p = 0; // 由符号*得到指针p所指的对象，即可经由p为变量ival赋值
    cout << *p; // 输出0
    ```

* 空指针
    ```
    int *p1 = nullptr;
    int *p2 = 0;
    int *p3= NULL:

    int zero = 0;
    pi = zero; // ❌， 不能把int变量直接赋给指针
    ```

* 赋值和指针
指针和引用都能提供对其他对象的间接访问，然而在具体实现细节上二者有很大不 同，其中最重要的一点就是引用本身并非一个对象。一旦定义了引用，就无法令其再绑定到另外的对象，之后每次使用这个引用都是访问它最初绑定的那个对象。
指针和它存放的地址之间就没有这种限制了。和其他任何变量(只要不是引用)一样，给指针赋值就是令它存放一个新的地址，从而指向一个新的对象。
    ```
    int i = 42;
    int *pi = 0; // pi被初始化，但没有指向任何对象
    int *pi2 = &i; // pi2被初始化，存有i的地址
    int *pi3; // 如果pi3定义于块内，则pi3的值是无法确定的

    pi3 = pi2; // pi3和pi2指向同一个对象i
    pi2 = 0; // 现在pi2不指向任何对象了
    ```
* 有时候要想搞清楚一条赋值语句到底是改变了指针的值还是改变了指针所指对象的值不太容易，最好的办法就是记住赋值永远改变的是等号左侧的对象
    ```
    pi = &ival; // pi的值被改变，现在pi指向了ival
    *pi = 0; // ival的值被改变，指针pi并没有改变，只是*pi（即指针pi指向的那个对象）发生改变
    ```

* void* 指针
```
double obj = 3.14, *pd = &obj; // 正确：void*能存放任意类型对象的地址
void *pv = &obj; // obj可以是任意类型的对象
pv = pd;  // pv可以存放任意类型的指针
```
* 练习 2.18 编写代码分别更改指针的值以及指针所指对象的值
    ```
    #include <iostream>

    int main()
    {
        int i = 42;
        int *pi = nullptr;
        pi = &i; // 改变pi指针，使其指向i
        std::cout << *pi << " " << std::endl;
        *pi = 0; // 改变i，使其变为0
        std::cout << *pi << " " << std::endl;
        return 0;
    }
    ```
* 练习 2.19 说明指针和引用的主要区别
    ```
    指针是一个变量，存储的是一个地址，指向内存的一个存储单元；
    引用是原变量的一个别名，跟原来的变量实质上是同一个东西。
    ```
* 练习 2.20 请叙述下面这段代码的作用
    ```
    int i = 42;
    int *p1 = &i; // p1是一个int型指针，指向变量i
    *p1 = *p1 * *p1; // 右侧 42 * 42 赋值给左侧 *p1（即p1指针指向的变量i） 所以这行代码意味着 i = 42 * 42;
    ```
* 练习 2.21 请解释下述定义。在这些定义中有非法的吗？如果有，为什么？
    ```
    int i = 0;
    a. double* dp = &i; // ❌ 指针dp和i的类型不一致
    b. int *ip = i; // ❌ 不能把int变量直接赋给指针
    c. int *p = &i; // ✅ 定义一个int型指针p，p指向i
    ```
* 练习 2.22 假设p是一个int型指针，请说明下述代码的含义
    ```
    if (p) // p的值 == p指针是否指向空
    if (*p) // *p的值 == p指针指向对象的值
    ```
* 练习 2.23 给空指针p，你能知道它是否指向了一个合法的对象吗？如果能，叙述判断的思路；如果不能，也请说明原因。
    ```
    如果不是一个void*，能，首先编译器会帮助我们进行判断，并给出错误提示。其次，我们可以尝试输出指针所指对象的值。非法时编译器会报错。但如果是一个void指针，我们没有办法访问内存空间中所存的对象，也就无法判断它是否指向了一个合法的对象
    ```
* 练习 2.24 在下面这段代码中为什么p合法而lp非法？
    ```
    int i = 42;
    void *p = &i; // void定义了一个空指针，可以接受任意类型的对象
    long *lp = &i; // lp的类型和i不一致
    ```

## 2.3.3 理解复合类型的声明

# 2.4 const 限定符